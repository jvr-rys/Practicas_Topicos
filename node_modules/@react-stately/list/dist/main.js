var $aJ74T$react = require("react");
var $aJ74T$reactstatelyselection = require("@react-stately/selection");
var $aJ74T$reactstatelycollections = require("@react-stately/collections");
var $aJ74T$reactstatelyutils = require("@react-stately/utils");

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $72e18dacc1c2def6$exports = {};

$parcel$export($72e18dacc1c2def6$exports, "useListState", () => $72e18dacc1c2def6$export$2f645645f7bca764);

var $581648861f39f723$exports = {};

$parcel$export($581648861f39f723$exports, "ListCollection", () => $581648861f39f723$export$d085fb9e920b5ca7);
class $581648861f39f723$export$d085fb9e920b5ca7 {
    constructor(nodes){
        this.keyMap = new Map();
        this.iterable = nodes;
        let visit = (node)=>{
            this.keyMap.set(node.key, node);
            if (node.childNodes && node.type === 'section') for (let child of node.childNodes)visit(child);
        };
        for (let node2 of nodes)visit(node2);
        let last;
        let index = 0;
        for (let [key, node1] of this.keyMap){
            if (last) {
                last.nextKey = key;
                node1.prevKey = last.key;
            } else {
                this.firstKey = key;
                node1.prevKey = undefined;
            }
            if (node1.type === 'item') node1.index = index++;
            last = node1;
            // Set nextKey as undefined since this might be the last node
            // If it isn't the last node, last.nextKey will properly set at start of new loop
            last.nextKey = undefined;
        }
        this.lastKey = last?.key;
    }
    *[Symbol.iterator]() {
        yield* this.iterable;
    }
    get size() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        return this.lastKey;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
}




function $72e18dacc1c2def6$export$2f645645f7bca764(props) {
    let { filter: filter  } = props;
    let selectionState = $aJ74T$reactstatelyselection.useMultipleSelectionState(props);
    let disabledKeys = $aJ74T$react.useMemo(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set()
    , [
        props.disabledKeys
    ]);
    let factory = (nodes)=>filter ? new $581648861f39f723$export$d085fb9e920b5ca7(filter(nodes)) : new $581648861f39f723$export$d085fb9e920b5ca7(nodes)
    ;
    let context = $aJ74T$react.useMemo(()=>({
            suppressTextValueWarning: props.suppressTextValueWarning
        })
    , [
        props.suppressTextValueWarning
    ]);
    let collection = $aJ74T$reactstatelycollections.useCollection(props, factory, context, [
        filter
    ]);
    // Reset focused key if that item is deleted from the collection.
    $aJ74T$react.useEffect(()=>{
        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
    }, [
        collection,
        selectionState.focusedKey
    ]);
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        selectionManager: new $aJ74T$reactstatelyselection.SelectionManager(collection, selectionState)
    };
}


var $bb463ca54c041eac$exports = {};

$parcel$export($bb463ca54c041eac$exports, "useSingleSelectListState", () => $bb463ca54c041eac$export$e7f05e985daf4b5f);



function $bb463ca54c041eac$export$e7f05e985daf4b5f(props) {
    let [selectedKey, setSelectedKey] = $aJ74T$reactstatelyutils.useControlledState(props.selectedKey, props.defaultSelectedKey ?? null, props.onSelectionChange);
    let selectedKeys = $aJ74T$react.useMemo(()=>selectedKey != null ? [
            selectedKey
        ] : []
    , [
        selectedKey
    ]);
    let { collection: collection , disabledKeys: disabledKeys , selectionManager: selectionManager  } = $72e18dacc1c2def6$export$2f645645f7bca764({
        ...props,
        selectionMode: 'single',
        disallowEmptySelection: true,
        allowDuplicateSelectionEvents: true,
        selectedKeys: selectedKeys,
        onSelectionChange: (keys)=>{
            let key = keys.values().next().value;
            // Always fire onSelectionChange, even if the key is the same
            // as the current key (useControlledState does not).
            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);
            setSelectedKey(key);
        }
    });
    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        selectionManager: selectionManager,
        selectedKey: selectedKey,
        setSelectedKey: setSelectedKey,
        selectedItem: selectedItem
    };
}



$parcel$exportWildcard(module.exports, $72e18dacc1c2def6$exports);
$parcel$exportWildcard(module.exports, $bb463ca54c041eac$exports);
$parcel$exportWildcard(module.exports, $581648861f39f723$exports);


//# sourceMappingURL=main.js.map
